<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Clean Code on Sergio Carracedo</title><link>https://sergiocarracedo.es/tags/clean-code/</link><description>Recent content in Clean Code on Sergio Carracedo</description><generator>Hugo</generator><language>en</language><lastBuildDate>Mon, 19 Aug 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://sergiocarracedo.es/tags/clean-code/index.xml" rel="self" type="application/rss+xml"/><item><title>Detecting circular dependencies in Javascript projects</title><link>https://sergiocarracedo.es/circular-dependencies/</link><pubDate>Mon, 19 Aug 2024 00:00:00 +0000</pubDate><guid>https://sergiocarracedo.es/circular-dependencies/</guid><description>&lt;p>Circular imports (or circular dependencies, or cycle dependencies, but not the same as circular references) are easy to have in your code base, and more when the code grows. It can impact in the bundle generation or cause issues (for example in HMR) and you should avoid them because they are a symptom of an incorrect architecture or code organization and is a big code smell.&lt;/p>
&lt;h2 id="what-are-circular-dependencies">What are circular dependencies&lt;/h2>
&lt;p>Circular dependencies occur when a package (A) depends on another package (B) and B also depends on A. Circular dependencies can be more complex: A depends on B, B on C, C on D and D on A&lt;/p></description></item><item><title>A real case: why hexagonal architecture, decoupling, and Dependency injection can be very useful in the frontend</title><link>https://sergiocarracedo.es/hexagonal-architecture-frontend/</link><pubDate>Mon, 20 May 2024 00:00:00 +0000</pubDate><guid>https://sergiocarracedo.es/hexagonal-architecture-frontend/</guid><description>&lt;p>Hexagonal architecture is a software design pattern based on the separation of responsibilities. The goal is to decouple the business logic (domain) and the application from other external interfaces.&lt;/p>
&lt;p>Simplifying in hexagonal architecture we communicate the core of the app (domain + application) with the external elements using ports and adapters. A &lt;strong>port&lt;/strong> lives in the core, it is the interface any external code must use to interact with the core (or the core with the external code), the &lt;strong>adapter&lt;/strong> is the external piece of code that follows the port interface and execute the tasks, get the data, etc.&lt;/p></description></item></channel></rss>