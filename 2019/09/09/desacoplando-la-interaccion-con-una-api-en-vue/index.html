<!doctype html><html><head><meta charset=utf-8><meta content="IE=edge,chrome=1" http-equiv=x-ua-compatible><meta content="width=device-width,minimum-scale=1" name=viewport><title>Sergio Carracedo | Desacoplando la interacción con una API en Vue: vue.$api</title><meta content="yes" name=apple-mobile-web-app-capable><meta content="black-translucent" name=apple-mobile-web-app-status-bar-style><meta content="Sergio Carracedo's personal page and blog" name=description><meta content="Sergio Carracedo" name=author><link href=/favicon.png rel=icon><meta property="og:title" content="Desacoplando la interacción con una API en Vue: vue.$api"><meta property="og:description" content="Durante el desarrollo de una web, una SPA en Vue es muy habitual que ese desarrollo implique interactuar con una API y lo habitual será que uses axios para ello (aunque lo que voy a explicar valdría para cualquiera otra librería)
Es muy habitual que cuando necesitamos interactuar con un endpoint de la API, lo hagamos directamente desde el controlador, entendiendo por controlador el componente que se encarga de responder a una ruta."><meta property="og:type" content="article"><meta property="og:url" content="https://sergiocarracedo.es/2019/09/09/desacoplando-la-interaccion-con-una-api-en-vue/"><meta property="og:image" content="https://sergiocarracedo.es/2019/09/09/desacoplando-la-interaccion-con-una-api-en-vue/vue-api_hue3e183c5fa902cd4ae789f3e908b1fee_262772_1920x1080_fill_q75_box_center.jpg"><meta name=twitter:image content="https://sergiocarracedo.es/2019/09/09/desacoplando-la-interaccion-con-una-api-en-vue/vue-api_hue3e183c5fa902cd4ae789f3e908b1fee_262772_1920x1080_fill_q75_box_center.jpg"></meta><meta property="article:section" content="blog"><meta property="article:published_time" content="2019-09-09T00:00:00+00:00"><meta property="article:modified_time" content="2019-09-09T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"></meta><link rel=canonical href=https://sergiocarracedo.es/2019/09/09/desacoplando-la-interaccion-con-una-api-en-vue/><link href=https://sergiocarracedo.es/scss/main.2fd96352cefb0fc6d22a709a5c49be2d08c4854cce0d451385d9b0e30adcce2e.css integrity="sha256-L9ljUs77D8bSKnCaXEm+LQjEhUzODUUThdmw4wrczi4=" rel=stylesheet><link href=//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.1.0/cookieconsent.min.css rel=stylesheet type=text/css></head><body><header class=web-header><h2><a class=back-to-home href=/ title="Back to home"><i class="fas fa-home"></i><div class=back-to-home__content><span class=back-to-home__action>Back to home</span><div class=back-to-home__title><img alt="Sergio Carracedo" class=avatar src=/i/sergiocarracedo_hu6caa808ff324b89bfea4b9d7d1c850ee_80590_100x100_fit_q75_box.jpg><h4>Sergio Carracedo</h4></div></div></a></h2><div class=web-header__page-title><span>Desacoplando la interacción con una API en Vue: vue.$api</span></div><div class=theme-switch><i class="theme-switch__theme fas fa-sun" id=theme-switch-light title="Switch to light theme"></i>
<i class="theme-switch__theme fas fa-moon" id=theme-switch-dark title="Switch to dark theme"></i></div></header><div class=main-content><article class="post post--single"><div class="post__main wrapper-1200"><aside class=post__metadata><time class=post__date datetime=2019-09-09><i class="far fa-calendar-alt"></i> Sep 9, 2019</time><div class=post__tags></div><span class=post__reading-time><i class="far fa-clock"></i> 5 minutes read</span></aside><header class=post__header><h1 class=post__title>Desacoplando la interacción con una API en Vue: vue.$api</h1></header><figure class=post__cover><img src=/2019/09/09/desacoplando-la-interaccion-con-una-api-en-vue/vue-api_hue3e183c5fa902cd4ae789f3e908b1fee_262772_1200x400_fill_q75_box_center.jpg alt="Desacoplando la interacción con una API en Vue: vue.$api" width=1200 height=400></figure><div class=post__content><p>Durante el desarrollo de una web, una SPA en <em>Vue</em> es muy habitual que ese desarrollo implique interactuar con una <em>API</em> y lo habitual será que uses <em><a href=https://github.com/axios/axios>axios</a></em> para ello (aunque lo que voy a explicar valdría para cualquiera otra librería)</p><p>Es muy habitual que cuando necesitamos interactuar con un <em>endpoint</em> de la <em>API</em>, lo hagamos directamente desde el controlador, entendiendo por controlador el componente que se encarga de responder a una ruta.</p><p>Por ejemplo:</p><pre tabindex=0><code>....
data() {
 return {
  users: []
 },
...
methods:
 ...
 getUsers(page) {
   axios({
      method: &#39;get&#39;,
      url: &#39;https://reqres.in/api/users&#39;,
      data: {
        page          
      }
    }).then(res =&gt; {
      this.users = res.data.data
    }).catch(res =&gt; {
      // Do something on error
    })  
 }   
...    
</code></pre><p>Esto cumple su función básica que es la de pedirle a la <em>API</em> la lista de usuarios de la página indicada y guardarlos en <em>users</em> para que este disponible para renderizar.</p><p>Se me ocurren varios problemas que nos podemos encontrar a botepronto:</p><ul><li>Si necesitamos pedir los usuarios desde varios controladores tendríamos que duplicar este código.</li><li>Si para hacer la llamada necesitamos añadir alguna cabecera de autorización, token o similar, tendríamos que saber en todas las llamadas a la <em>API</em> que usen esa autentificación aplicarlo y usarlo desde una variable de entorno que deberíamos conocer.</li><li>La gestión de errores puede ser tediosa, si por ejemplo siempre que la <em>API</em> responda un error lo vamos a mostrar en pantalla de la misma forma tendríamos que programarlo en cada llamada.</li><li>Lo mismo si usamos <em>loaders</em> en pantalla, tenemos que acordarnos de añadirlos cada vez que usemos una llamada a la <em>API</em>.</li></ul><p>Una solución más elegante seria mover las llamadas a la <em>API</em> a funciones en un fichero externo que importamos en cada controlador y de las que hacemos uso:</p><pre tabindex=0><code>import Api from &#39;./api.js&#39;
....
data() {
 return {
  users: []
 },
...
methods:
 ...
 getUsers(page) {
  Api.getUsers(page)
    .then(res =&gt; {
      this.users = res.data.data
    })
 }   
...    
</code></pre><p>Y el contenido de <code>api.js</code> sería:</p><pre tabindex=0><code>export default {
  getUsers: function (page) {
    return axios({
       method: &#39;get&#39;,
       url: &#39;https://reqres.in/api/users&#39;,
       data: {
         page          
       }
     }) 
  }
}  
</code></pre><p>Con esto además de simplificar el código ya podríamos reusar la llamada a la <em>API</em> en varios controladores.</p><p>Si queremos que cada vez que hagamos una llamada a la <em>API</em> se muestre un cargador en el front (y este desaparezca al terminar la carga), seria razonable usar <em><a href=https://vuex.vuejs.org/>vuex</a></em> o similar para esto, entonces nuestro <em>controlador</em> quedaría así</p><pre tabindex=0><code>import Api from &#39;./api.js&#39;
....
data() {
 return {
  users: []
 },
...
methods:
 ...
 getUsers(page) {
  this.$store.commit(&#39;loading&#39;, true)
  Api.getUsers(page)
    .then(res =&gt; {
    this.$store.commit(&#39;loading&#39;, false)
      this.users = res.data.data
    })
    .catch(error =&gt; {
      this.$store.commit(&#39;loading&#39;, false)
    })
 }   
...    
</code></pre><p>(Doy por supuesto que hay un store que tiene una mutación encargada de mostrar un componente <em>loading</em> en la UI)</p><p>Pero, de esta forma volvemos a tener el mismo problema, para cada llamada a la función que gestiona la <em>API</em> tenemos que acordarnos de hacer el <em>commit</em> al <em>store</em> tanto al principio de la llamada como cuando devuelve datos como, importante, cuando hay un error.</p><p>Vale, llevemos esto a nuestro <code>api.js</code></p><pre tabindex=0><code>import store from &#39;./store.js&#39; // Donde tengamos nuestra store definida

export default {
  getUsers: function (page) {
    store.commit(&#39;loading&#39;, true)
    return 
      axios({
        method: &#39;get&#39;,
        url: &#39;https://reqres.in/api/users&#39;,
        data: {
          page          
        }
      })
      .then(res =&gt; {
        store.commit(&#39;loading&#39;, false)
      })
      .catch(error =&gt; {
        store.commit(&#39;loading&#39;, false)
      })
  }
}  
</code></pre><p><strong>OJO</strong>, pero si dejamos esto así, al capturar la resolución de la <em>promesa</em> (con el <em>then</em> y el <em>catch</em>), nuestro controlador no recibirá dicha resolución, por lo que tenemos que reenviarselas de la siguiente forma:</p><pre tabindex=0><code>import store from &#39;./store.js&#39; // Donde tengamos nuestra store definida

export default {
  getUsers: function (page) {
    store.commit(&#39;loading&#39;, true)
    return 
      axios({
        method: &#39;get&#39;,
        url: &#39;https://reqres.in/api/users&#39;,
        data: {
          page          
        }
      })
      .then(res =&gt; {
        store.commit(&#39;loading&#39;, false)
        return res // &lt;--- Devolvemos la misma promesa ya resuelta (propagamos)
      })
      .catch(error =&gt; {
        store.commit(&#39;loading&#39;, false)
        throw error // &lt;-- Lanzamos de nuevo la misma excepción
      })
  }
}  
</code></pre><p>De esta forma el propagar la resolución de la promesa el controlador ni se ha enterado que hemos lanzado el <em>loader</em> y lo hemos desactivado.</p><p>Vale, pues ahora, porqué, en lugar de tener que importar <code>api.js</code> en cada controlador, no hacemos que esté disponible en toda la app, de la misma forma que lo esta, por ejemplo la <em>store</em> de <em>vuex</em>: &lsquo;vue.$store&rsquo; es decir: &lsquo;vue.$api.getUsers()&rsquo;</p><p>Para ello creamos un plugin de <em>vue</em>, que es tan sencillo como lo siguiente en nuestro <code>api.js</code></p><pre tabindex=0><code>import store from &#39;./store.js&#39; // Donde tengamos nuestra store definida
import axios from &#39;axios&#39;

export default {
  install (Vue) {
    Vue.prototype.$api = Api
  }
}
const Api = {
  getUsers: function (page) {
    store.commit(&#39;loading&#39;, true)
    return 
      axios({
        method: &#39;get&#39;,
        url: &#39;https://reqres.in/api/users&#39;,
        data: {
          page          
        }
      })
      .then(res =&gt; {
        store.commit(&#39;loading&#39;, false)
        return res // &lt;--- Devolvemos la misma promesa ya resuelta (propagamos)
      })
      .catch(error =&gt; {
        store.commit(&#39;loading&#39;, false)
        throw error // &lt;-- Lanzamos de nuevo la misma excepción
      })
  }
}  
</code></pre><p>Y nuestro <em>entrypoint</em>, que suele ser <code>main.js</code>, lo dejamos como algo así:</p><pre tabindex=0><code>import Vue from &#34;vue&#34;;
import App from &#34;./App.vue&#34;;
import Api from &#34;./api.js&#34;; // &lt;----------------

Vue.config.productionTip = false;

Vue.use(Api) // &lt;----------------

new Vue({
  render: h =&gt; h(App)
}).$mount(&#34;#app&#34;);
</code></pre><p>Ahora ya tenemos disponible el acceso al objecto <em>Api</em> en cualquier controlador con solo usar <code>this.$api.getUser()</code>, y en el caso de nuestro ejemplo quedaría</p><pre tabindex=0><code>...
data() {
 return {
  users: []
 },
...
methods:
 ...
 getUsers(page) {
  this.$api.getUsers(page)
    .then(res =&gt; {
      this.users = res.data.data
    })
 }   
...    
</code></pre><p>Obviamente nuestro objeto <em>Api</em> puede tener más funciones que hagan llamadas a otros endpoints, tener una forma común de mostrar errores, etc. Eso se lo dejo a vuestra imaginación</p><p>Por último, y como <em>spoiler</em> de un próximo <em>post</em>, decir que si hacemos uso de muchos endpoints distintos, el fichero <code>api.js</code> puede ser enorme y lo razonable sería trocearlo, e incluso separar las el objecto de la entidad a la que acceda, por ejemplo <code>this.$api.user.get</code> o <code>this.$api.user.create</code> o <code>this.$api.billing.list</code> o cualquier otro ejemplo que se os ocurra, pero como digo eso da para otro <em>post</em>.</p></div></div><aside class=post__nav-wrapper><div class=wrapper-1200><div class="post-nav post-nav--prev"><a class=post-nav__link href="https://sergiocarracedo.es/2019/09/26/pulpocon-19/?ref=footer"><div class=post-nav__cover><img alt=.NextPage.Title src=/2019/09/26/pulpocon-19/pulpocon_hu79e8f8632e01815440c52553d6e18931_534031_200x120_fill_q75_box_center.jpg></div><div class=post-nav__title>Mi edificante experiencia ayudando a organizar la...</div></a></div><div class=blog-link><a class=btn href=https://sergiocarracedo.es/blog>All Blog posts</a></div><div class="post-nav post-nav--next"><a class=post-nav__link href="https://sergiocarracedo.es/2019/09/02/Unificando-la-informacion-de-eventos-de-una-comunidad-vigotech-json/?ref=footer"><div class=post-nav__cover><img alt=.PrevPage.Title class=post-nav__cover src=/2019/09/02/Unificando-la-informacion-de-eventos-de-una-comunidad-vigotech-json/vigotech_hue3e183c5fa902cd4ae789f3e908b1fee_178875_200x120_fill_q75_box_center.jpg></div><div class=post-nav__title>Unificando la información de eventos de una...</div></a></div></div></aside><aside class=post__comments><div class=wrapper-1200><div id=disqus_thread>To show the comments is mandatory accept cookie policy.</div></div></aside></article></div><footer class=web-footer><div class=wrapper-1200><div class=web-footer__left><div class=me><div class=me__avatar><img alt="Sergio Carracedo" src=/i/sergiocarracedo_hu6caa808ff324b89bfea4b9d7d1c850ee_80590_170x170_fit_q75_box.jpg></div><div class=me__titles><h1>Sergio Carracedo</h1><h2>Senior Fullstack developer.</h2><h3>Formula 1, cats, good conversations and small details lover.</h3></div></div></div><div class=web-footer__right><nav role=main class=menu><ul><li class=menu__item><a href=https://sergiocarracedo.es/>Home</a></li><li class=menu__item><a href=https://sergiocarracedo.es/blog>Blog</a></li></ul></nav><div class=social><a class=social__link href=http://www.linkedin.com/in/sergiocarracedo target=_blank title=LinkedIn style=animation-delay:2s><i class="fab fa-linkedin"></i></a>
<a class=social__link href=mailto:hi+blog@sergiocarracedo.es target=_blank title=Email style=animation-delay:1.9333333333333333s><i class="fas fa-envelope"></i></a>
<a class=social__link href=https://github.com/sergiocarracedo target=_blank title=GitHub style=animation-delay:1.8666666666666667s><i class="fab fa-github"></i></a>
<a class=social__link href=https://www.drupal.org/u/sergiocarracedo target=_blank title=Drupal style=animation-delay:1.8s><i class="fab fa-drupal"></i></a>
<a class=social__link href=https://www.twitter.com/sergiocarracedo target=_blank title=Twitter style=animation-delay:1.7333333333333334s><i class="fab fa-twitter"></i></a>
<a class=social__link href=http://www.last.fm/user/gasman40 target=_blank title=Last.fm style=animation-delay:1.6666666666666667s><i class="fab fa-lastfm"></i></a>
<a class=social__link href=http://sergiocarracedo.tumblr.com/ target=_blank title=Tumblr style=animation-delay:1.6s><i class="fab fa-tumblr"></i></a></div></div></div></footer><script async src="https://www.googletagmanager.com/gtag/js?id=UA-133459072-1"></script>
<script>function runGA(){window.dataLayer=window.dataLayer||[];function e(){dataLayer.push(arguments)}e("js",new Date),e("config","UA-133459072-1")}</script><script>function runDisqus(){(function(){var e=document,t=e.createElement("script");t.src="https://sergiocarracedo.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()}</script><script src=//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.1.0/cookieconsent.min.js></script>
<script>window.addEventListener("load",function(){window.cookieconsent.initialise({palette:{popup:{background:"#004262",text:"#fff"},button:{background:"#8ec760",text:"#ffffff"}},type:"opt-out",content:{message:"Este sitio usa cookies propias y de terceros para mejorar la experiencia de usuario y esas cosas.",allow:"Ok, continua",deny:"Nada de cookies",link:"Saber más",href:"https://sergiocarracedo.es/cookies"},onStatusChange:function(e){e=="allow"&&runCookiesAllowed()},onInitialise:function(e){e=="allow"&&runCookiesAllowed()}})})</script><script>addEventListener("scroll",e=>{let t=document.getElementsByTagName("body")[0];t&&window.scrollY>10?t.classList.add("not-in-top"):t.classList.remove("not-in-top")});function runCookiesAllowed(){runGA(),runDisqus()}</script><script integrity="sha256-6W09eoRhk1Og2XFEl4eaBSED33MOr8P1V5qaL3z+PEY=" src=https://sergiocarracedo.es/js/theme.e96d3d7a84619353a0d9714497879a052103df730eafc3f5579a9a2f7cfe3c46.js></script></body></html>