<!doctype html><html><head><meta charset=utf-8><meta content="IE=edge,chrome=1" http-equiv=x-ua-compatible><meta content="width=device-width,minimum-scale=1" name=viewport><title>Sergio Carracedo | Understanding Javascript's event loop: Macrotasks and microtasks</title><meta content="yes" name=apple-mobile-web-app-capable><meta content="black-translucent" name=apple-mobile-web-app-status-bar-style><meta content="Sergio Carracedo's personal page and blog" name=description><meta content="Sergio Carracedo" name=author><link href=/favicon.png rel=icon><meta property="og:title" content="Understanding Javascript's event loop: Macrotasks and microtasks"><meta property="og:description" content="Despite what it may seem, Javascript execution in a browser is synchronous. It is a similar thing as a multitask OS running in a mono-core processor, in that case multitasking is &ldquo;fake&rdquo;, because the processor can only execute one instruction at a time, but the OS controls the execution and distribute the processor time between each app, making it looks like multitasking.
In Javascript we have a similar approximation in a way to distribute the execution time."><meta property="og:type" content="article"><meta property="og:url" content="https://sergiocarracedo.es/2020/04/27/js-loop/"><meta property="og:image" content="https://sergiocarracedo.es/2020/04/27/js-loop/js-event-loop-106155_huc7440f1b92e5d652fec108b39f7d180d_346363_1920x1080_fill_q75_box_center.jpg"><meta name=twitter:image content="https://sergiocarracedo.es/2020/04/27/js-loop/js-event-loop-106155_huc7440f1b92e5d652fec108b39f7d180d_346363_1920x1080_fill_q75_box_center.jpg"></meta><meta property="article:section" content="blog"><meta property="article:published_time" content="2020-04-27T00:00:00+00:00"><meta property="article:modified_time" content="2020-04-27T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"></meta><link rel=canonical href=https://sergiocarracedo.es/2020/04/27/js-loop/><link href=https://sergiocarracedo.es/scss/main.2fd96352cefb0fc6d22a709a5c49be2d08c4854cce0d451385d9b0e30adcce2e.css integrity="sha256-L9ljUs77D8bSKnCaXEm+LQjEhUzODUUThdmw4wrczi4=" rel=stylesheet><link href=//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.1.0/cookieconsent.min.css rel=stylesheet type=text/css></head><body><header class=web-header><h2><a class=back-to-home href=/ title="Back to home"><i class="fas fa-home"></i><div class=back-to-home__content><span class=back-to-home__action>Back to home</span><div class=back-to-home__title><img alt="Sergio Carracedo" class=avatar src=/i/sergiocarracedo_hu6caa808ff324b89bfea4b9d7d1c850ee_80590_100x100_fit_q75_box.jpg><h4>Sergio Carracedo</h4></div></div></a></h2><div class=web-header__page-title><span>Understanding Javascript's event loop: Macrotasks and microtasks</span></div><div class=theme-switch><i class="theme-switch__theme fas fa-sun" id=theme-switch-light title="Switch to light theme"></i>
<i class="theme-switch__theme fas fa-moon" id=theme-switch-dark title="Switch to dark theme"></i></div></header><div class=main-content><article class="post post--single"><div class="post__main wrapper-1200"><aside class=post__metadata><time class=post__date datetime=2020-04-27><i class="far fa-calendar-alt"></i> Apr 27, 2020</time><div class=post__tags><a href=https://sergiocarracedo.es/tags/js class=post__tag><span>js</span></a></div><span class=post__reading-time><i class="far fa-clock"></i> 4 minutes read</span></aside><header class=post__header><h1 class=post__title>Understanding Javascript's event loop: Macrotasks and microtasks</h1></header><figure class=post__cover><img src=/2020/04/27/js-loop/js-event-loop-106155_huc7440f1b92e5d652fec108b39f7d180d_346363_1200x400_fill_q75_box_center.jpg alt="Understanding Javascript's event loop: Macrotasks and microtasks" width=1200 height=400></figure><div class=post__content><p>Despite what it may seem, Javascript execution in a browser is <em>synchronous</em>. It is a similar thing as a <em>multitask</em> OS running in a mono-core processor, in that case multitasking is &ldquo;fake&rdquo;, because the processor can only execute one instruction at a time, but the OS controls the execution and distribute the processor time between each app, making it looks like multitasking.</p><p>In <em>Javascript</em> we have a similar approximation in a way to distribute the execution time. It&rsquo;s not exactly the same. Lets see how it works.</p><h1 id=event-loop>Event loop</h1><p>When you write a program in JS, every script you add or every instruction will be added to a queue in the <em>event loop</em></p><p>The engine starts to run every instruction in the same order you wrote, running all tasks, and when finish, it waits for more tasks and then starts again.</p><p>Every task in this queue is a <strong>macrotask</strong> and queue is the <strong>macrotask queue</strong>. Some examples of macrotasks are:</p><ul><li>Every <code>&lt;script></code> loaded and all the instructions on them</li><li><code>setInterval</code> or <code>setTimeout</code> command</li><li>DOM event: <code>window.load</code>, <code>mouseout</code>, etc</li></ul><p>In example below, we run some task: calculate the 6th element on Fibonacci series and get a string with the English alphabet. I put some <code>console.log</code> as code execution checkpoint to show the execution order.</p><iframe frameborder=0 marginheight=0 marginwidth=0 width=100% height=500px type=text/html src="https://codesandbox.io/s/romantic-lewin-i1fjz?fontsize=14&amp;hidenavigation=1&amp;previewwindow=console&amp;runonclick=1&amp;initialpath=macrotasks.html&amp;module=/src/macrotasks.js&amp;theme=dark"></iframe><p>The result is</p><pre tabindex=0><code>Checkpoint 1 
13
Checkpoint 2: 0.5600000149570405ms 
ABCDEFGHIJKLMNOPQRSTUVWXYZ 
Checkpoint 3 
</code></pre><p>As you can see, the tasks run in order, string generation doesn&rsquo;t start until fibonacci function finish, even if the function takes long time to be completed.</p><p>Let&rsquo;s see what happens when you use <code>setTimeout</code>. When you set a timeout, you expect your function will be executed after the timeout you set. For example <code>setTimeout(() => console.log('here'), 1000)</code> should print in console &lsquo;here&rsquo; after <strong>1s</strong>. You expect this always happens, no cares about next task or instructions. If you expect that, you are wrong. Check next code:</p><iframe frameborder=0 marginheight=0 marginwidth=0 width=100% height=500px type=text/html src="https://codesandbox.io/s/romantic-lewin-i1fjz?fontsize=14&amp;hidenavigation=1&amp;previewwindow=console&amp;runonclick=1&amp;initialpath=macrotasksSetTimeout.html&amp;module=/src/macrotasksSetTimeout.js&amp;theme=dark"></iframe><p>We have a long task after the timeout. Timeout should be executed after <strong>1s</strong>, but next task takes <strong>5s</strong> to be completed, and your timeout not executed yet. Ok let&rsquo;s wait long task end, and&mldr; nothing, your timeout still missing. Next macrotask is our string generator, this task is executed and, finally, after all macrotask, our timeout is executed.</p><p>That occurs because, when you use a timeout, you are moving the task at the end of the queue, an at this point is when js engine checks if your timeout should be executed.</p><h2 id=taking-advantage>Taking advantage</h2><p>You can take advantage of that event loop behavior, for example, you can put a high CPU usage task inside a <code>setTimeout</code>, even with 0ms of dispatch time, and this huge task will be executed after following tasks.
That is a fast solution, but if you have more than 1 or 2 long tasks, you are only moving the problem to the end of the queue, but problem is still there.</p><h2 id=using-promises>Using Promises</h2><p>You could think of using promises, for example</p><iframe frameborder=0 marginheight=0 marginwidth=0 width=100% height=500px type=text/html src="https://codesandbox.io/s/romantic-lewin-i1fjz?fontsize=14&amp;hidenavigation=1&amp;previewwindow=console&amp;runonclick=1&amp;initialpath=macrotasksPromise.html&amp;module=/src/macrotasksPromise.js&amp;theme=dark"></iframe><p>But the promise starts to run the code inside just after call the promise&rsquo;s constructor, and your program is stucked again. You can resolve it using <code>setTimeout</code> again, but in this case we are creating a <strong>microtask</strong>:</p><h2 id=microtasks>Microtasks</h2><p>Microtasks are tasks created in promises (then, catch, finally). The microtask queue run immediately after every macrotask, before render or before the next macrotask</p><iframe frameborder=0 marginheight=0 marginwidth=0 width=100% height=500px type=text/html src="https://codesandbox.io/s/romantic-lewin-i1fjz?fontsize=14&amp;hidenavigation=1&amp;previewwindow=console&amp;runonclick=1&amp;initialpath=microtasksPromise.html&amp;module=/src/microtasksPromise.js&amp;theme=dark"></iframe><p>In that example, <code>setTimeout</code> creates a new macrotask, so it will run after macrotask loop, Promise creates a microtask that will be executed after next macrotrask ends, in this case after all script instructions but before the queued macrostask. And finally will run the <code>setTimeout</code> macrotask</p><p>There are another way to create a microtask, using <a href=https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/queueMicrotask><code>queueMicrotask</code></a> that is a recent addition to the standard. it&rsquo;s supported by most modern browsers (<a href="https://caniuse.com/#search=queueMicrotask">https://caniuse.com/#search=queueMicrotask</a>) but if not, you can use this polyfill:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>typeof</span> window.<span style=color:#a6e22e>queueMicrotask</span> <span style=color:#f92672>!==</span> <span style=color:#e6db74>&#39;function&#39;</span>) {
</span></span><span style=display:flex><span>  window.<span style=color:#a6e22e>queueMicrotask</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>callback</span>) {
</span></span><span style=display:flex><span>    Promise.<span style=color:#a6e22e>resolve</span>()
</span></span><span style=display:flex><span>      .<span style=color:#a6e22e>then</span>(<span style=color:#a6e22e>callback</span>)
</span></span><span style=display:flex><span>      .<span style=color:#66d9ef>catch</span>(<span style=color:#a6e22e>e</span> =&gt; <span style=color:#a6e22e>setTimeout</span>(() =&gt; { <span style=color:#66d9ef>throw</span> <span style=color:#a6e22e>e</span> }))
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And works exactly as the previous example but syntax is clearer</p><iframe frameborder=0 marginheight=0 marginwidth=0 width=100% height=500px type=text/html src="https://codesandbox.io/s/romantic-lewin-i1fjz?fontsize=14&amp;hidenavigation=1&amp;previewwindow=console&amp;runonclick=1&amp;initialpath=microtasksPromise.html&amp;module=/src/microtasksPromise.js&amp;theme=dark"></iframe><h2 id=vue>Vue</h2><p>If you are using Vue, maybe you can show a loader or some kind of indicator when you go to execute a long task.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>...
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>data</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>loading</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>methods</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>longTask</span> () {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>loading</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// doing your long task stuff
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>loading</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>You could think that the loader will be showed before start the long task and hidden after it, but that not happens, you never see the loader, because the reactive properties are &ldquo;checked&rdquo; after the loop and at this point <code>this.loading</code> is <code>false</code>.</p><p>You can try to use <code>$.nextTick</code> but the result it&rsquo;s the same, you need to get out of the event loop with your long task</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>...
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>data</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>loading</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>methods</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>longTask</span> () {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>loading</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>queueMicrotask</span>(() =&gt; {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// doing your long task stuff)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>loading</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>      
</span></span><span style=display:flex><span>      }      
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>Above I wrote that Javascript is <em>synchronous</em>, but I lied ðŸ˜…. You can use <a href=https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers>WebWorkers</a>, this is topic for another post&mldr; :simple_smile:</p><p>More info: <a href=https://javascript.info/event-loop>https://javascript.info/event-loop</a></p></div></div><aside class=post__nav-wrapper><div class=wrapper-1200><div class="post-nav post-nav--prev"><a class=post-nav__link href="https://sergiocarracedo.es/2020/05/09/js-unary-operators-and-taking-advantage/?ref=footer"><div class=post-nav__cover><img alt=.NextPage.Title src=/2020/05/09/js-unary-operators-and-taking-advantage/unary-operators-1364700_hu0e030d2148397c28a575d420e6d617a4_239941_200x120_fill_q75_box_center.jpg></div><div class=post-nav__title>Javascript unary operators: Taking advantage using...</div></a></div><div class=blog-link><a class=btn href=https://sergiocarracedo.es/blog>All Blog posts</a></div><div class="post-nav post-nav--next"><a class=post-nav__link href="https://sergiocarracedo.es/2020/04/05/slimbook-prox15-first-impressions/?ref=footer"><div class=post-nav__cover><img alt=.PrevPage.Title class=post-nav__cover src=/2020/04/05/slimbook-prox15-first-impressions/cover_hu9848d94371263e5ed91da245a1dd9e10_989849_200x120_fill_q75_box_center.jpg></div><div class=post-nav__title>Slimbook ProX 15: First Impressions</div></a></div></div></aside><aside class=post__comments><div class=wrapper-1200><div id=disqus_thread>To show the comments is mandatory accept cookie policy.</div></div></aside></article></div><footer class=web-footer><div class=wrapper-1200><div class=web-footer__left><div class=me><div class=me__avatar><img alt="Sergio Carracedo" src=/i/sergiocarracedo_hu6caa808ff324b89bfea4b9d7d1c850ee_80590_170x170_fit_q75_box.jpg></div><div class=me__titles><h1>Sergio Carracedo</h1><h2>Senior Fullstack developer.</h2><h3>Formula 1, cats, good conversations and small details lover.</h3></div></div></div><div class=web-footer__right><nav role=main class=menu><ul><li class=menu__item><a href=https://sergiocarracedo.es/>Home</a></li><li class=menu__item><a href=https://sergiocarracedo.es/blog>Blog</a></li></ul></nav><div class=social><a class=social__link href=http://www.linkedin.com/in/sergiocarracedo target=_blank title=LinkedIn style=animation-delay:2s><i class="fab fa-linkedin"></i></a>
<a class=social__link href=mailto:hi+blog@sergiocarracedo.es target=_blank title=Email style=animation-delay:1.9333333333333333s><i class="fas fa-envelope"></i></a>
<a class=social__link href=https://github.com/sergiocarracedo target=_blank title=GitHub style=animation-delay:1.8666666666666667s><i class="fab fa-github"></i></a>
<a class=social__link href=https://www.drupal.org/u/sergiocarracedo target=_blank title=Drupal style=animation-delay:1.8s><i class="fab fa-drupal"></i></a>
<a class=social__link href=https://www.twitter.com/sergiocarracedo target=_blank title=Twitter style=animation-delay:1.7333333333333334s><i class="fab fa-twitter"></i></a>
<a class=social__link href=http://www.last.fm/user/gasman40 target=_blank title=Last.fm style=animation-delay:1.6666666666666667s><i class="fab fa-lastfm"></i></a>
<a class=social__link href=http://sergiocarracedo.tumblr.com/ target=_blank title=Tumblr style=animation-delay:1.6s><i class="fab fa-tumblr"></i></a></div></div></div></footer><script async src="https://www.googletagmanager.com/gtag/js?id=G-87X78TXEGE"></script>
<script>function runGA(){window.dataLayer=window.dataLayer||[];function e(){dataLayer.push(arguments)}e("js",new Date),e("config","G-87X78TXEGE")}</script><script>function runDisqus(){(function(){var e=document,t=e.createElement("script");t.src="https://sergiocarracedo.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()}</script><script src=//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.1.0/cookieconsent.min.js></script>
<script>window.addEventListener("load",function(){window.cookieconsent.initialise({palette:{popup:{background:"#004262",text:"#fff"},button:{background:"#8ec760",text:"#ffffff"}},type:"opt-out",content:{message:"Este sitio usa cookies propias y de terceros para mejorar la experiencia de usuario y esas cosas.",allow:"Ok, continua",deny:"Nada de cookies",link:"Saber mÃ¡s",href:"https://sergiocarracedo.es/cookies"},onStatusChange:function(e){e=="allow"&&runCookiesAllowed()},onInitialise:function(e){e=="allow"&&runCookiesAllowed()}})})</script><script>addEventListener("scroll",e=>{let t=document.getElementsByTagName("body")[0];t&&window.scrollY>10?t.classList.add("not-in-top"):t.classList.remove("not-in-top")});function runCookiesAllowed(){runGA(),runDisqus()}</script><script integrity="sha256-6W09eoRhk1Og2XFEl4eaBSED33MOr8P1V5qaL3z+PEY=" src=https://sergiocarracedo.es/js/theme.e96d3d7a84619353a0d9714497879a052103df730eafc3f5579a9a2f7cfe3c46.js></script></body></html>