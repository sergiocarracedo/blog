<!doctype html><html><head><meta charset=UTF-8><meta content="IE=edge,chrome=1" http-equiv=X-UA-Compatible><meta content="width=device-width,minimum-scale=1" name=viewport><title>Sergio Carracedo | The advantage of using cache to decouple the frontend code</title>
<meta content="yes" name=apple-mobile-web-app-capable><meta content="black-translucent" name=apple-mobile-web-app-status-bar-style><meta content="Sergio Carracedo's personal page and blog" name=description><meta content="Sergio Carracedo" name=author><link href=https://sergiocarracedo.es//index.xml rel=alternate title="Sergio Carracedo" type=application/rss+xml><link href=/apple-touch-icon.png rel=apple-touch-icon sizes=180x180><link href=/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=/favicon-16x16.png rel=icon sizes=16x16 type=image/png><link href=/site.webmanifest rel=manifest><link color=#5bbad5 href=/safari-pinned-tab.svg rel=mask-icon><meta content="#da532c" name=msapplication-TileColor><meta content="#ffffff" name=theme-color><link crossorigin href="https://fonts.googleapis.com/css2?family=Rozha+One:wght@400;500;600;700&display=swap" rel=preconnect><link crossorigin href="https://fonts.googleapis.com/css2?family=Merriweather:wght@400;500;600;700&display=swap" rel=preconnect><link crossorigin href="https://fonts.googleapis.com/css2?family=Allura:wght@400;500;600;700&display=swap" rel=preconnect><meta property="og:title" content="The advantage of using cache to decouple the frontend code"><meta property="og:description" content="We can agree decoupling is a good practice that simplifies the code and the maintainability of the project.
A common way of decoupling the code is to divide the responsibilities into different layers, a very common division is:

view layer: in charge of render HTML and interacting with the user
domain layer: in charge of the business logic
infra layer: in charge of getting the data from the backend and returning it to the domain layer(here is very common to use the repository pattern, which is just a contract to get the data. The contract is unique but you can have multiple implementations, for example, one for a REST API and another for a GraphQL API, you should be able to change the implementation without changing other pieces in the code)

Let&rsquo;s see a couple of examples use cases where it is very typical to put the performance over the decoupling. (Spoiler: we can have both)"><meta property="og:type" content="article"><meta property="og:url" content="https://sergiocarracedo.es/using-cache-to-decouple-frontend-code/"><meta property="og:image" content="https://sergiocarracedo.es/using-cache-to-decouple-frontend-code/kimi-lee-Dsg--4yCqCI-unsplash_hu12933979547328330372.jpg"><meta name=twitter:image content="https://sergiocarracedo.es/using-cache-to-decouple-frontend-code/kimi-lee-Dsg--4yCqCI-unsplash_hu12933979547328330372.jpg"></meta><meta property="article:section" content="blog">
<meta property="article:published_time" content="2023-11-20T00:00:00+00:00"><meta property="article:modified_time" content="2023-11-20T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"></meta>
<link href=https://sergiocarracedo.es/using-cache-to-decouple-frontend-code/ rel=canonical><link href=https://sergiocarracedo.es/scss/main.min.eb2c7eed36db73868d33fc79aad24debed56125f83ac18652aad76126b0014a7.css integrity="sha256-6yx+7Tbbc4aNM/x5qtJN6+1WEl+DrBhlKq12EmsAFKc=" rel="stylesheet preconnect"><link href=//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.1.0/cookieconsent.min.css rel="stylesheet preload" type=text/css></head><body><header class="web-header background-paper-secondary"><h2><a class=back-to-home href=/ title="Back to home"><i class="fas fa-home"></i><div class=back-to-home__content><span class=back-to-home__action>Back to home</span><div class=back-to-home__title><img alt="Sergio Carracedo" class=avatar src=/i/sergiocarracedo_hu15161314200389136556.jpg><h4>Sergio Carracedo</h4></div></div></a></h2><div class=web-header__page-title><span>The advantage of using cache to decouple the frontend code</span></div><div class=theme-switch><i class="theme-switch__theme fas fa-sun" id=theme-switch-light title="Switch to light theme"></i>
<i class="theme-switch__theme fas fa-moon" id=theme-switch-dark title="Switch to dark theme"></i></div></header><div class=main-content><article class="post post--single"><div class="post__main wrapper-1200"><aside class=post__metadata><time class=post__date datetime=2023-11-20><i class="far fa-calendar-alt"></i> Nov 20, 2023
</time><a href=https://sergiocarracedo.es/tags/typescript class=post__tag><span>typescript</span>
</a><a href=https://sergiocarracedo.es/tags/javascript class=post__tag><span>javascript</span>
</a><a href=https://sergiocarracedo.es/tags/infra class=post__tag><span>infra</span>
</a><a href=https://sergiocarracedo.es/tags/frontend class=post__tag><span>frontend</span>
</a><span class=post__reading-time><i class="far fa-clock"></i> 8 minutes read</span></aside><header class=post__header><h1 class=post__title>The advantage of using cache to decouple the frontend code</h1></header><figure class=post__cover><img alt="The advantage of using cache to decouple the frontend code" height=400 src=/using-cache-to-decouple-frontend-code/kimi-lee-Dsg--4yCqCI-unsplash_hu1867577716594451367.jpg width=1200></figure><div class=post__content><p>We can agree decoupling is a good practice that simplifies the code and the maintainability of the project.</p><p>A common way of decoupling the code is to divide the responsibilities into different layers, a very common division is:</p><ul><li><strong>view layer</strong>: in charge of render HTML and interacting with the user</li><li><strong>domain layer</strong>: in charge of the business logic</li><li><strong>infra layer</strong>: in charge of getting the data from the backend and returning it to the domain layer(here is very common to use the repository pattern, which is just a contract to get the data. The contract is unique but you can have multiple implementations, for example, one for a REST API and another for a GraphQL API, you should be able to change the implementation without changing other pieces in the code)</li></ul><p>Let&rsquo;s see a couple of examples use cases where it is very typical to put the performance over the decoupling. (Spoiler: we can have both)</p><p>Imagine, you have an endpoint that returns the list of products, and one of the fields is the <code>category_id</code>, the response can be something like this (I removed other fields to make a simple example)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>[
</span></span><span style=display:flex><span>  { <span style=color:#960050;background-color:#1e0010>id:</span> <span style=color:#960050;background-color:#1e0010>1,</span> <span style=color:#960050;background-color:#1e0010>name:</span> <span style=color:#f92672>&#34;Product 1&#34;</span>, <span style=color:#960050;background-color:#1e0010>category_id:</span> <span style=color:#960050;background-color:#1e0010>1</span> }, 
</span></span><span style=display:flex><span>  { <span style=color:#960050;background-color:#1e0010>id:</span> <span style=color:#960050;background-color:#1e0010>2,</span> <span style=color:#960050;background-color:#1e0010>name:</span> <span style=color:#f92672>&#34;Product 2&#34;</span>, <span style=color:#960050;background-color:#1e0010>category_id:</span> <span style=color:#960050;background-color:#1e0010>2</span> },
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>...</span>
</span></span><span style=display:flex><span>]
</span></span></code></pre></div><p>We need to show the category name in the frontend (not the id), so we need to call another endpoint to get the category name, that endpoint returns something like</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>[
</span></span><span style=display:flex><span>  { <span style=color:#960050;background-color:#1e0010>id:</span> <span style=color:#960050;background-color:#1e0010>1,</span> <span style=color:#960050;background-color:#1e0010>name:</span> <span style=color:#f92672>&#34;Mobile&#34;</span> }, 
</span></span><span style=display:flex><span>  { <span style=color:#960050;background-color:#1e0010>id:</span> <span style=color:#960050;background-color:#1e0010>2,</span> <span style=color:#960050;background-color:#1e0010>name:</span> <span style=color:#f92672>&#34;TVs&#34;</span> },
</span></span><span style=display:flex><span>  { <span style=color:#960050;background-color:#1e0010>id:</span> <span style=color:#960050;background-color:#1e0010>3,</span> <span style=color:#960050;background-color:#1e0010>name:</span> <span style=color:#f92672>&#34;Keyboards&#34;</span> },
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>...</span>
</span></span><span style=display:flex><span>]
</span></span></code></pre></div><blockquote><p>You can think the backend should do the join, and return all-in-one requests, but that is not always possible</p></blockquote><p>We can do the join in the frontend, in the function or method in charge of recovering the products, we can do both requests and join the information. Example</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>getProductList</span>()<span style=color:#f92672>:</span> <span style=color:#a6e22e>Promise</span>&lt;<span style=color:#f92672>Product</span><span style=color:#960050;background-color:#1e0010>[]</span>&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>products</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>fetchProducts</span>();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>categories</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>fetchCategories</span>();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>products</span>.<span style=color:#a6e22e>map</span>(<span style=color:#a6e22e>product</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>category</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>categories</span>.<span style=color:#a6e22e>find</span>(<span style=color:#a6e22e>category</span> <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>category</span>.<span style=color:#a6e22e>id</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>product</span>.<span style=color:#a6e22e>category_id</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> { ...<span style=color:#a6e22e>product</span>, <span style=color:#a6e22e>category_name</span>: <span style=color:#66d9ef>category.name</span> };
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Our application doesn&rsquo;t need to know anything about we need 2 calls to recover the information, and we can use the <code>category_name</code> in the frontend without any problem.</p><p>Now imagine you need to show the list of categories, for example in a dropdown. You can reuse the <code>fetchCategories</code> function, as it does exactly what you need.</p><p>In your view the code is something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-vue data-lang=vue><span style=display:flex><span>&lt;<span style=color:#f92672>template</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>dropdown</span> <span style=color:#f92672>:options</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;categories&#34;</span> /&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>product-list</span> <span style=color:#f92672>:products</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;products&#34;</span> /&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>template</span>&gt;
</span></span><span style=display:flex><span>&lt;<span style=color:#f92672>script</span> <span style=color:#a6e22e>lang</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;ts&#34;</span> <span style=color:#a6e22e>setup</span>&gt;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>fetchCategories</span>, <span style=color:#a6e22e>getProductList</span> } <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;@/repositories&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>categories</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>await</span> <span style=color:#a6e22e>fetchCategories</span>();
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>products</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>await</span> <span style=color:#a6e22e>getProductList</span>();
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>script</span>&gt;
</span></span></code></pre></div><p>And in that point, you realize you are doing 2 calls to the same endpoint to recover the same data, data you recovered to compose the product list, and that is not good in terms of performance, network load, backend load, etc.</p><p>At this moment, you start to think about how to reduce the number of calls to the backend, in this case, to just reuse the category list. You can have the temptation of moving the calls to the view and doing the join of the products and the categories.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-vue data-lang=vue><span style=display:flex><span><span style=color:#75715e>// ❌❌❌ Not nice solution 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>&lt;<span style=color:#f92672>template</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>dropdown</span> <span style=color:#f92672>:options</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;categories&#34;</span> /&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>product-list</span> <span style=color:#f92672>:products</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;products&#34;</span> /&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>template</span>&gt;
</span></span><span style=display:flex><span>&lt;<span style=color:#f92672>script</span> <span style=color:#a6e22e>lang</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;ts&#34;</span> <span style=color:#a6e22e>setup</span>&gt;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>fetchCategories</span>, <span style=color:#a6e22e>fetchProducts</span> } <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;@/repositories&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>categories</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>await</span> <span style=color:#a6e22e>fetchCategories</span>();
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>products</span> <span style=color:#f92672>=</span>  <span style=color:#a6e22e>await</span> <span style=color:#a6e22e>fetchProducts</span>().<span style=color:#a6e22e>map</span>(<span style=color:#a6e22e>product</span> =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>category</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>categories</span>.<span style=color:#a6e22e>find</span>(<span style=color:#a6e22e>category</span> =&gt; <span style=color:#a6e22e>category</span>.<span style=color:#a6e22e>id</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>product</span>.<span style=color:#a6e22e>category_id</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> { ...<span style=color:#a6e22e>product</span>, <span style=color:#a6e22e>category_name</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>category</span>.<span style=color:#a6e22e>name</span> };
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>script</span>&gt;
</span></span></code></pre></div><p>With that, you resolved the performance problems, but you added another BIG problem: <strong>infra, view and domain coupling</strong>. Now your view knows the shape of the data in the infra (backend), and makes it hard to reuse the code. We can go deep on this and do things even worse, what happens, if your head bar (is in another component that needs the list of categories), you need to think about the application in a global way.</p><p>Imagine something more complex, a scenario where you need the categories in the header, product list, filters, and the footer</p><p><img alt=img.png src=/using-cache-to-decouple-frontend-code/img.png></p><p>With the previous approach, your app layer (Vue, react, etc) needs to think about how to get the data to minimize the requests. And that is not good, as the app layer should be focused on the view, not on the infra.</p><h2 id=using-a-global-store>Using a global store</h2><p>One solution to this problem is to use a global store (vuex, pinia, redux, etc) to delegate the requests and just use the store in the view. The store only should load the data if is not loaded yet, and the view should not care about how the data is loaded. <strong>This sounds like cache, right?</strong> We solve the performance issue, but we&rsquo;re still having infra and view coupled.</p><h2 id=infra-cache-to-the-rescue>Infra cache to the rescue</h2><p>To decouple as much as possible the infra and the view, we should move the cache to the infra layer (the layer in charge of getting the data from the backend). Doing that we can call the infra methods at any time doing just a single request to the backend, but the important concept is that the domain, the application, and the view know nothing about the cache, about the network speed, the number of requests, etc.</p><p>The infra layer is just a layer to get the data with a contract (how to ask for the data and how the data is returned), following the decoupling principles we should be able to change the infra layer implementation without changing the domain, application or view layers. For example, we can replace the backend that uses REST by a backend that uses GraphQL, and we can get the product with the category names without doing 2 requests. But again, <strong>this is something the infra layer should care about, not the view.</strong></p><p>There are <a href=https://sergiocarracedo.es/front-end-cache-strategies-you-should-know/>different strategies you can follow to implement the cache</a> in the infra layer: HTTP cache (Proxy or Browser internal cache), but in these cases for better flexibility invalidating the caches in the frontend it&rsquo;s better our application (infra layer again) manage the cache.</p><p>If you are using axios you can use <a href=https://axios-cache-interceptor.js.org/>Axios Cache Interceptor</a> to manage the cache in the infra layer. This library makes caching very simple:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#75715e>// Example from axios cache interceptor page
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>Axios</span> <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;axios&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>setupCache</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;axios-cache-interceptor&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// same object, but with updated typings.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>axios</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>setupCache</span>(<span style=color:#a6e22e>Axios</span>); 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>req1</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>axios</span>.<span style=color:#66d9ef>get</span>(<span style=color:#e6db74>&#39;https://api.example.com/&#39;</span>); 
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>req2</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>axios</span>.<span style=color:#66d9ef>get</span>(<span style=color:#e6db74>&#39;https://api.example.com/&#39;</span>); 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>res1</span>, <span style=color:#a6e22e>res2</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>Promise</span>.<span style=color:#a6e22e>all</span>([<span style=color:#a6e22e>req1</span>, <span style=color:#a6e22e>req2</span>]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>res1</span>.<span style=color:#a6e22e>cached</span>; <span style=color:#75715e>// false 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>res2</span>.<span style=color:#a6e22e>cached</span>; <span style=color:#75715e>// true
</span></span></span></code></pre></div><p>You only need to wrap the axios instance with the cache interceptor, and the library will take care of the rest.</p><h2 id=ttl>TTL</h2><p><a href=https://en.wikipedia.org/wiki/Time_to_live>TTL</a> is the time the cache will be valid, after that time the cache will be invalidated and the next request will be done to the backend. The TTL is a very important concept, as it defines how fresh the data is.</p><p>When you are caching data a challenging problem is data inconsistency. In our example, we can think of a shopping cart. If it&rsquo;s cached and the user adds a new product if you apps a request to get the updated version of the cart it will get the cached version, and the user will not see the new product. There are strategies to invalidate the cache and solve this problem, but that is out of the scope of this post, but you need to know that is not a trivial problem: Different uses cases need different strategies.</p><p>As longer the TTL is, bigger the data inconsistency problem is, as more events can happen in that time.</p><p>But for the goal we are looking for (allowing to decouple the code easily), a very low TTL (ex. 10 seconds) is enough to remove the data inconsistency problem.</p><h3 id=why-a-low-ttl-is-enough>Why a low TTL is enough?</h3><p>Think about how the user interacts with the application:</p><ul><li>The user will ask for a url (it can be part of a SPA or a SSR page)</li><li>The application will create the layout of the page, mounting the independent components: the header, the footer, the filters, and the content (product list in the example)</li><li>Each component asks for the data it needs to do</li><li>The application will render the page with the data recovered and send it to the browser (SSR) or inject/update it in the DOM (SPA)</li></ul><p><img alt=img_2.png src=/using-cache-to-decouple-frontend-code/img_2.png></p><p>All those processes are repeated in each page change (maybe partially in a SPA) and the most important thing, are executed in a short period of time (maybe milliseconds). So with a low TTL we can be pretty sure we will do only a request to the backend, and we will not have data inconsistency problems as in the next page change or user interaction the cached expired and we will get the fresh data.</p><h2 id=summarizing>Summarizing</h2><p>This caching strategy in low TTL is a very good solution to decouple the infra and the view:</p><ul><li>Developers doesn&rsquo;t need to think about how to get the data to minimize the requests in the view layer. If you need the list of the categories in a sub-component you ask for it, don&rsquo;t need to about if another component is requesting the same data.</li><li>Avoids maintaining a global app state (stores)</li><li>Makes more natural to do multiple requests follow the contract in a repository pattern to get the data you need in the repository layer, and do the join in the infra layer.</li><li>In general terms simplifies the code complexity.</li><li>No cache invalidation challenged (as the TTL is very low) (Maybe for some very specific use cases)</li></ul></div></div><aside class=post__nav-wrapper><div class=wrapper-1200><div class="post-nav post-nav--prev"><a class=post-nav__link href="https://sergiocarracedo.es/spa-vue-react-angular-app-loader/?ref=footer"><div class="post-nav__cover btn btn--img btn--hover-parent"><img alt=.Next.Title src=/spa-vue-react-angular-app-loader/pexels-jeshoots-4956_hu8532605527008209095.jpg></div><div class=post-nav__title>SPA (Vue / React / Angular) app loader</div></a></div><div class=blog-link><a class="btn btn--outlined" href=https://sergiocarracedo.es/blog>All Blog posts</a></div><div class="post-nav post-nav--next"><a class=post-nav__link href="https://sergiocarracedo.es/typescript-tips/?ref=footer"><div class="post-nav__cover btn btn--img btn--hover-parent"><img alt=.Prev.Title class=post-nav__cover src=/typescript-tips/pexels-flo-maderebner-869258_hu4291573795781102850.jpg></div><div class=post-nav__title>Typescript tips for legacy projects: Type only you...</div></a></div></div><div class="wrapper-1200 post__nav-years"><ul class=years><li><a class=link href=https://sergiocarracedo.es/blog/by-year#2024>2024</a></li><li><a class=link href=https://sergiocarracedo.es/blog/by-year#2023>2023</a></li><li><a class=link href=https://sergiocarracedo.es/blog/by-year#2022>2022</a></li><li><a class=link href=https://sergiocarracedo.es/blog/by-year#2021>2021</a></li><li><a class=link href=https://sergiocarracedo.es/blog/by-year#2020>2020</a></li><li><a class=link href=https://sergiocarracedo.es/blog/by-year#2019>2019</a></li><li><a class=link href=https://sergiocarracedo.es/blog/by-year#2018>2018</a></li><li><a class=link href=https://sergiocarracedo.es/blog/by-year#2017>2017</a></li><li><a class=link href=https://sergiocarracedo.es/blog/by-year#2016>2016</a></li><li><a class=link href=https://sergiocarracedo.es/blog/by-year#2015>2015</a></li><li><a class=link href=https://sergiocarracedo.es/blog/by-year#2013>2013</a></li><li><a class=link href=https://sergiocarracedo.es/blog/by-year#2012>2012</a></li><li><a class=link href=https://sergiocarracedo.es/blog/by-year#2011>2011</a></li><li><a class=link href=https://sergiocarracedo.es/blog/by-year#2010>2010</a></li></ul></div></aside><aside class=post__search-wrapper><div class=wrapper-1200>Search in <strong>144</strong> blog posts:<form action=https://sergiocarracedo.es/search class="search-form search-form--dark search-form--l" method=get><label for=search-input hidden>Search</label>
<input class=search-form__input id=search-input name=query placeholder=Search type=text>
<button aria-label="Search in the blog" class=search-form__button>
<i class="fas fa-search"></i></button></form></div></aside><aside class=post__comments><div class=wrapper-1200><div id=disqus_thread>To show comments is mandatory to accept cookie policy.</div></div></aside></article></div><footer class="web-footer background-paper-secondary"><div class=wrapper-1200><div class=web-footer__left><div class=me><div class=me__avatar><img alt="Sergio Carracedo" height=180 src=/i/sergiocarracedo_hu3613990337080381956.jpg width=180></div><div class=me__titles><h1>Sergio Carracedo</h1><h2>Senior Fullstack developer.</h2><h3>Always learning, cats, good conversations and small details lover.</h3></div></div></div><div class=web-footer__right><nav class=menu><ul role=menu><li class=menu__item role=presentation><a role=menuitem href=https://sergiocarracedo.es/>Home</a></li><li class=menu__item role=presentation><a role=menuitem href=https://sergiocarracedo.es/blog>Blog</a></li><li class=menu__item role=presentation><a role=menuitem href=https://sergiocarracedo.es/index.xml>RSS Feed</a></li></ul></nav><div class=social><a class=social__link href=http://www.linkedin.com/in/sergiocarracedo target=_blank title=LinkedIn style=animation-delay:2s><i class="fab fa-linkedin"></i>
</a><a class=social__link href=mailto:hi+blog@sergiocarracedo.es target=_blank title=Email style=animation-delay:1.9333333333333333s><i class="fas fa-envelope"></i>
</a><a class=social__link href=https://github.com/sergiocarracedo target=_blank title=GitHub style=animation-delay:1.8666666666666667s><i class="fab fa-github"></i>
</a><a class=social__link href=https://bsky.app/profile/sergiocarracedo.bsky.social target=_blank title=Bluesky style=animation-delay:1.8s><svg fill="none" viewBox="0 0 64 57"><path fill="currentcolor" d="M13.873 3.805C21.21 9.332 29.103 20.537 32 26.55v15.882c0-.338-.13.044-.41.867-1.512 4.456-7.418 21.847-20.923 7.944-7.111-7.32-3.819-14.64 9.125-16.85-7.405 1.264-15.73-.825-18.014-9.015C1.12 23.022.0 8.51.0 6.55.0-3.268 8.579-.182 13.873 3.805zm36.254.0C42.79 9.332 34.897 20.537 32 26.55v15.882c0-.338.13.044.41.867 1.512 4.456 7.418 21.847 20.923 7.944 7.111-7.32 3.819-14.64-9.125-16.85 7.405 1.264 15.73-.825 18.014-9.015C62.88 23.022 64 8.51 64 6.55c0-9.818-8.578-6.732-13.873-2.745z"/></svg>
</a><a class=social__link href=https://www.drupal.org/u/sergiocarracedo target=_blank title=Drupal style=animation-delay:1.7333333333333334s><i class="fab fa-drupal"></i>
</a><a class=social__link href=https://www.npmjs.com/~sergiocarracedo target=_blank title=Npm style=animation-delay:1.6666666666666667s><svg viewBox="0 0 780 250" aria-hidden="true"><path fill="currentcolor" d="M240 250h1e2v-50h1e2V0H240V250zM340 50h50v1e2h-50V50zM480 0v2e2h1e2V50h50v150h50V50h50v150h50V0H480zM0 2e2h1e2V50h50v150h50V0H0V2e2z" stroke-width="5" stroke="currentcolor"/></svg>
</a><a class=social__link href=https://www.twitter.com/sergiocarracedo target=_blank title=Twitter style=animation-delay:1.6s><i class="fab fa-twitter"></i>
</a><a class=social__link href=http://www.last.fm/user/gasman40 target=_blank title=Last.fm style=animation-delay:1.5333333333333332s><i class="fab fa-lastfm"></i>
</a><a class=social__link href=http://sergiocarracedo.tumblr.com/ target=_blank title=Tumblr style=animation-delay:1.4666666666666668s><i class="fab fa-tumblr"></i></a></div></div></div></footer><script async src="https://www.googletagmanager.com/gtag/js?id=G-87X78TXEGE"></script><script>function runGA(){window.dataLayer=window.dataLayer||[];function e(){dataLayer.push(arguments)}e("js",new Date),e("config","G-87X78TXEGE")}</script><script>function runDisqus(){(function(){var e=document,t=e.createElement("script");t.src="https://sergiocarracedo.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()}</script><script src=//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.1.0/cookieconsent.min.js></script><script>window.addEventListener("load",function(){window.cookieconsent.initialise({palette:{popup:{background:"#004262",text:"#fff"},button:{background:"#8ec760",text:"#ffffff"}},type:"opt-out",content:{message:"Este sitio usa cookies propias y de terceros para mejorar la experiencia de usuario y esas cosas.",allow:"Ok, continua",deny:"Nada de cookies",link:"Saber más",href:"https://sergiocarracedo.es/cookies"},onStatusChange:function(e){e=="allow"&&runCookiesAllowed()},onInitialise:function(e){e=="allow"&&runCookiesAllowed()}})})</script><script>addEventListener("scroll",e=>{let t=document.getElementsByTagName("body")[0];t&&window.scrollY>10?t.classList.add("not-in-top"):t.classList.remove("not-in-top")});function runCookiesAllowed(){runGA(),runDisqus()}</script><script integrity="sha256-hyPros3hoBf0jJM1+zayQLFFkchXwy4d/k2QMvk0sHs=" src=https://sergiocarracedo.es/js/theme.min.8723eba2cde1a017f48c9335fb36b240b14591c857c32e1dfe4d9032f934b07b.js></script><script src=https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js type=text/javascript></script><script integrity="sha256-RbHPlXzHpytxkjPwfQ5YOIACraziwCE1p/czQA3M/hM=" src=https://sergiocarracedo.es/js/search.min.45b1cf957cc7a72b719233f07d0e58388002adace2c02135a7f733400dccfe13.js></script></body></html>